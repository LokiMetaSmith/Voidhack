<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LCARS Terminal</title>
    <link rel="icon" href="data:,">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Antonio:wght@400;700&display=swap');

        :root {
            --lcars-orange: #ff9900;
            --lcars-purple: #cc99cc;
            --lcars-blue: #9999ff;
            --lcars-red: #cc0000;
            --lcars-bg: #000000;
            --lcars-text: #000000;
            --lcars-light-text: #ff9900;
        }

        body {
            background-color: var(--lcars-bg);
            color: var(--lcars-orange);
            font-family: 'Antonio', sans-serif;
            margin: 0;
            padding: 0;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* LCARS Layout */
        .lcars-container {
            display: grid;
            grid-template-columns: 150px 1fr;
            grid-template-rows: 100px 1fr 50px;
            height: 100%;
            gap: 10px;
            padding: 10px;
        }

        /* Header */
        .lcars-header {
            grid-column: 1 / -1;
            background-color: var(--lcars-purple);
            border-radius: 0 0 0 50px; /* The curve */
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 20px;
            font-size: 48px;
            font-weight: bold;
            color: var(--lcars-text);
            text-transform: uppercase;
        }

        /* Sidebar */
        .lcars-sidebar {
            grid-column: 1;
            grid-row: 2;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .lcars-button {
            background-color: var(--lcars-blue);
            color: var(--lcars-text);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: 20px;
            font-weight: bold;
            border-radius: 30px 0 0 30px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .lcars-button:hover {
            background-color: #ddddff;
        }

        .lcars-button.active {
            background-color: var(--lcars-orange);
        }

        .lcars-spacer {
            flex-grow: 1;
            background-color: var(--lcars-bg);
        }

        .lcars-elbow {
            height: 100px;
            background-color: var(--lcars-purple);
            border-radius: 0 0 0 50px;
        }

        /* Main Content */
        .lcars-main {
            grid-column: 2;
            grid-row: 2;
            border: 2px solid var(--lcars-orange);
            border-radius: 20px; /* Inner screen look */
            padding: 20px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: 20px;
            overflow-y: auto;
        }

        .status-panel {
            grid-column: 1 / -1;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: space-around;
        }

        .system-display {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100px;
        }

        .bar-container {
            width: 40px;
            height: 200px;
            background-color: #333;
            position: relative;
            margin-bottom: 10px;
            border: 1px solid var(--lcars-orange);
        }

        .bar-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background-color: var(--lcars-orange);
            transition: height 0.5s ease-in-out;
        }

        .system-name {
            font-size: 18px;
            text-transform: uppercase;
        }

        .system-value {
            font-size: 24px;
            font-weight: bold;
        }

        .log-panel {
            grid-column: 1 / -1;
            border-top: 1px solid var(--lcars-orange);
            padding-top: 10px;
            font-family: monospace;
            color: var(--lcars-light-text);
            height: 150px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .log-entry.system {
            color: #999999;
            font-size: 0.9em;
        }

        .log-entry.chat {
            color: var(--lcars-orange);
            font-weight: bold;
        }

        .log-panel.hide-system .log-entry.system {
            display: none;
        }

        /* Footer */
        .lcars-footer {
            grid-column: 1 / -1;
            text-align: right;
            color: var(--lcars-orange);
            font-size: 14px;
        }

        #init-btn {
            background-color: var(--lcars-red);
            color: white;
        }

        #listening-indicator {
            display: none;
            color: var(--lcars-red);
            font-weight: bold;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            50% { opacity: 0; }
        }

        @keyframes flash-gold {
            0% { background-color: var(--lcars-bg); }
            50% { background-color: #554400; }
            100% { background-color: var(--lcars-bg); }
        }

    </style>
</head>
<body>

    <div class="lcars-container">
        <div class="lcars-header">
            USS ENTERPRISE <span style="margin-left: 20px; font-size: 24px;">NCC-1701-D</span>
        </div>

        <div class="lcars-sidebar">
            <div class="lcars-button" id="init-btn" onclick="initComms()">INIT COMMS</div>
            <div class="lcars-button">MODE</div>
            <div class="lcars-button" id="logs-btn" onclick="toggleLogs()">LOGS</div>
            <div class="lcars-spacer"></div>
            <div class="lcars-elbow"></div>
        </div>

        <div class="lcars-main">
            <div class="status-panel" id="status-panel">
                <!-- Systems generated here -->
            </div>

            <div style="grid-column: 1/-1; text-align: center;">
                <h2 id="listening-indicator">LISTENING...</h2>
                <p id="last-command">Awaiting input...</p>
            </div>

            <div class="log-panel" id="log-panel">
                SYSTEM READY.
            </div>
        </div>

        <div class="lcars-footer">
            LCARS 47983.2
        </div>
    </div>

    <!-- Silent Audio Loop for Hack -->
    <audio id="silent-audio" loop>
        <source src="data:audio/wav;base64,UklGRigAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQAAAAA=" type="audio/wav">
    </audio>

    <script>
        const API_URL = window.location.origin;
        const silentAudio = document.getElementById('silent-audio');
        const logPanel = document.getElementById('log-panel');
        let recognition;

        // State Flags
        let isMicActive = false;
        let isSystemSpeaking = false; // Flag to prevent Mic restart during TTS
        let commandWindowEnd = 0; // Timestamp: ignore speech after this time
        let showSystemLogs = true;
        let wakeLock = null; // Added back
        let isOnboarding = false; // Flag for first-time user setup
        let userId = localStorage.getItem('lcars_user_id');

        if (!userId) {
            userId = 'user_' + Math.random().toString(36).substr(2, 9);
            localStorage.setItem('lcars_user_id', userId);
        }

        // INSTANT COMMAND CONFIG (Turbo Mode)
        const PRE_DEFINED_COMMANDS = [
            { regex: /shield(s)?\s+(up|raise|maximum)/i, response: "Shields raised.", updates: { shields: 100 } },
            { regex: /shield(s)?\s+(down|lower|off)/i, response: "Shields lowered.", updates: { shields: 0 } },
            { regex: /red\s+alert/i, response: "Red Alert! Shields and Phasers at maximum.", updates: { shields: 100, phasers: 100 } },
            { regex: /warp\s+(engage|go)/i, response: "Warp drive engaged.", updates: { warp: 90 } },
            { regex: /warp\s+(stop|disengage)/i, response: "Warp drive disengaged.", updates: { warp: 0 } },
            { regex: /phaser(s)?\s+(arm|lock)/i, response: "Phasers armed.", updates: { phasers: 100 } },
            { regex: /status(\s+report)?/i, response: "Systems nominal. Displaying current status.", updates: {} }
        ];

        // Profiling
        let t_trigger = 0;
        let lastInterimTime = 0; // Track when we last heard silence
        let listeningTimeout = null; // Auto-close window if no speech

        // Audio Context for Chirp
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

        function toggleLogs() {
            showSystemLogs = !showSystemLogs;
            const btn = document.getElementById('logs-btn');
            if (showSystemLogs) {
                logPanel.classList.remove('hide-system');
                btn.classList.remove('active');
            } else {
                logPanel.classList.add('hide-system');
                btn.classList.add('active');
            }
        }

        function playChirp(type='start') {
            if (audioCtx.state === 'suspended') {
                audioCtx.resume().catch(e => console.warn("AudioContext resume failed", e));
            }
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            if (type === 'start') {
                oscillator.type = 'sine';
                oscillator.frequency.setValueAtTime(1000, audioCtx.currentTime);
                oscillator.frequency.exponentialRampToValueAtTime(2000, audioCtx.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.1, audioCtx.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'processing') {
                // TNG "Computer Working" low trill
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
                oscillator.frequency.linearRampToValueAtTime(1200, audioCtx.currentTime + 0.05);
                oscillator.frequency.linearRampToValueAtTime(800, audioCtx.currentTime + 0.1);

                gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.15);

                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.15);
            }
        }

        // --- WAKE LOCK (Re-added) ---
        async function requestWakeLock() {
            try {
                wakeLock = await navigator.wakeLock.request('screen');
                log("Screen Wake Lock active.", "system");
                document.addEventListener('visibilitychange', async () => {
                    if (wakeLock !== null && document.visibilityState === 'visible') {
                        wakeLock = await navigator.wakeLock.request('screen');
                    }
                });
            } catch (err) {
                log(`Wake Lock Error: ${err.name}`, "error");
            }
        }

        function triggerFeedback() {
            // Audio Chirp (Requested)
            playChirp('start');

            // Tactile Feedback
            if (navigator.vibrate) {
                navigator.vibrate(200);
            }
            document.getElementById('listening-indicator').style.display = 'block';
        }

        function log(msg, type = 'system') {
            requestAnimationFrame(() => {
                const line = document.createElement('div');
                line.className = `log-entry ${type}`;
                line.textContent = `> ${msg}`;
                logPanel.appendChild(line);
                logPanel.scrollTop = logPanel.scrollHeight;
            });
        }

        // --- MAIN INITIALIZATION ---
        async function initComms() {
            try {
                await requestWakeLock(); // Re-added

                // Resume audio context on user gesture
                if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }

                // 1. Start Silent Loop (Keeps Media Session alive)
                await silentAudio.play();
                log("Comms Initialized. Silent loop active.", "system");

                const initBtn = document.getElementById('init-btn');
                initBtn.textContent = "ACTIVE";
                initBtn.style.backgroundColor = "#9999ff";

                // 2. Setup Media Session (Headset Button)
                if ('mediaSession' in navigator) {
                    navigator.mediaSession.metadata = new MediaMetadata({
                        title: 'LCARS Comms',
                        artist: 'Enterprise Computer',
                        album: 'Main Bridge'
                    });
                    const actionHandler = () => handleHeadsetTrigger();
                    navigator.mediaSession.setActionHandler('pause', actionHandler);
                    navigator.mediaSession.setActionHandler('play', actionHandler);
                }

                // 3. Start "Hot Mic" immediately
                setupSpeechRecognition();
                startContinuousMic();

                // 4. Check Onboarding Status
                const savedHandle = localStorage.getItem('lcars_handle');
                if (!savedHandle) {
                    isOnboarding = true;
                    // Prompt user after a brief delay to ensure systems are ready
                    setTimeout(() => {
                        speak("Communication link established. Please state your identity.");
                        // Open the gate automatically for the reply
                        openChannel(10000);
                        log("Channel Open for Identity Confirmation...", "system");
                    }, 1000);
                } else {
                     log(`Identity confirmed: ${savedHandle}`, "system");
                }

            } catch (err) {
                log("Error initializing comms: " + err, "error");
            }
        }

        // --- LOGIC: THE "GATE" ---
        function handleHeadsetTrigger() {
            t_trigger = performance.now();
            openChannel(5000);
            log("Channel Open. Waiting for input...", "system");
        }

        function openChannel(durationMs) {
            commandWindowEnd = Date.now() + durationMs;

            triggerFeedback();

            // Reset Timeout
            if (listeningTimeout) clearTimeout(listeningTimeout);
            listeningTimeout = setTimeout(() => {
                // If window closed and we are still "Listening", close UI
                if (Date.now() >= commandWindowEnd) {
                    document.getElementById('listening-indicator').style.display = 'none';
                    // Optional: log("Channel Closed (Timeout).", "system");
                }
            }, durationMs + 100); // Small buffer

            // Ensure silent audio resumes if the OS paused it
            if (silentAudio.paused) {
                 silentAudio.play().catch(e => {});
            }
        }

        // --- SPEECH RECOGNITION (ALWAYS ON) ---
        function setupSpeechRecognition() {
            if (!('webkitSpeechRecognition' in window)) {
                log("Web Speech API not supported.");
                return;
            }

            recognition = new webkitSpeechRecognition();
            recognition.continuous = true;  // Keep listening
            recognition.interimResults = true; // Get data faster
            recognition.lang = 'en-US';

            recognition.onstart = () => {
                isMicActive = true;
                log("Microphone Hot. Background monitoring active.", "system");
                // Try to keep the button alive
                if (silentAudio.paused) silentAudio.play().catch(e => {});
            };

            recognition.onend = () => {
                isMicActive = false;
                // AUTO-RESTART: Keep the mic hot!
                // Only if the system ISN'T speaking (prevent echo)
                setTimeout(() => {
                    if (document.visibilityState === 'visible' && !isSystemSpeaking) {
                        startContinuousMic();
                        // Ensure button stays alive
                        if (silentAudio.paused) silentAudio.play().catch(e => {});
                    }
                }, 100);
            };

            recognition.onresult = (event) => {
                let finalTranscript = '';
                let interimTranscript = '';
                let isFinal = false;

                for (let i = event.resultIndex; i < event.results.length; ++i) {
                    if (event.results[i].isFinal) {
                        finalTranscript += event.results[i][0].transcript;
                        isFinal = true;
                    } else {
                        interimTranscript += event.results[i][0].transcript;
                    }
                }

                // CHECK INTERIM RESULTS FOR "TURBO" COMMANDS
                if (Date.now() < commandWindowEnd && interimTranscript.length > 0) {
                     lastInterimTime = Date.now();

                     // Attempt to match interim transcript against known commands
                     for (const cmd of PRE_DEFINED_COMMANDS) {
                         if (cmd.regex.test(interimTranscript)) {
                             log(`Fast-Match: "${interimTranscript}"`, "chat");
                             handleInstantCommand(interimTranscript, cmd);
                             return; // Stop processing
                         }
                     }

                     // SILENCE KILLER: If we have interim results but user stopped speaking
                     // Check again in 800ms. If no update, stop mic.
                     setTimeout(() => {
                         if (isMicActive && Date.now() - lastInterimTime > 800 && Date.now() < commandWindowEnd) {
                             // User likely finished speaking short command
                             if (recognition) recognition.stop(); // Force Finalization
                         }
                     }, 850);
                }

                // FILTER: Only process if the "Button Gate" is open
                if (isFinal && finalTranscript.trim().length > 0) {
                    if (Date.now() < commandWindowEnd) {
                        // Check exact match on final (if interim missed it or wasn't used)
                         for (const cmd of PRE_DEFINED_COMMANDS) {
                             if (cmd.regex.test(finalTranscript)) {
                                 log(`Fast-Match (Final): "${finalTranscript}"`, "chat");
                                 handleInstantCommand(finalTranscript, cmd);
                                 return;
                             }
                         }

                        // Valid Command
                        log(`Heard: "${finalTranscript}"`, "chat");
                        document.getElementById('last-command').textContent = finalTranscript;

                        // Close the gate immediately after hearing a command
                        commandWindowEnd = 0;
                        document.getElementById('listening-indicator').style.display = 'none';

                        if (isOnboarding) {
                            // Handle Onboarding Response
                            localStorage.setItem('lcars_handle', finalTranscript);
                            isOnboarding = false;

                            // Register User with Backend
                            fetch(API_URL + '/user', {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ user_id: userId, name: finalTranscript })
                            }).then(res => res.json()).then(data => {
                                speak(`Identity confirmed, ${data.rank} ${finalTranscript}. Systems online.`);
                                log(`User registered: ${data.rank} ${finalTranscript}`, "system");
                            }).catch(err => {
                                console.error("Registration failed", err);
                                speak(`Identity confirmed, ${finalTranscript}. Warning: Database connection failed.`);
                            });

                        } else {
                            // Normal Command
                            // Play "Processing" sound to fill the gap
                            playChirp('processing');
                            sendCommand(finalTranscript);
                        }
                    } else {
                        // Ignored (Background noise / Hot Mic buffer)
                        // log(`(Ignored): "${finalTranscript}"`, "system");
                    }
                }
            };

            recognition.onerror = (event) => {
                if (event.error !== 'no-speech') {
                    log("Speech Error: " + event.error, "error");
                }
            };
        }

        function startContinuousMic() {
            if (recognition && !isMicActive) {
                try {
                    recognition.start();
                } catch (e) {
                    // Ignore "already started" errors
                }
            }
        }

        // --- INSTANT COMMAND HANDLER ---
        function handleInstantCommand(text, cmdData) {
            // Close gate
            commandWindowEnd = 0;
            if (listeningTimeout) clearTimeout(listeningTimeout); // Stop timeout
            document.getElementById('listening-indicator').style.display = 'none';
            document.getElementById('last-command').textContent = text;

            // 1. Optimistic UI Update (0ms)
            updateStatusUI(cmdData.updates);

            // 2. Instant TTS (0ms)
            // We set isSystemSpeaking to true immediately so the mic restart logic works correctly
            isSystemSpeaking = true;
            if(recognition) recognition.abort(); // Hard stop to reset

            log("Computer (Fast): " + cmdData.response, "chat");
            speak(cmdData.response);

            // 3. Sync Backend (Fire & Forget)
            sendCommand(text, true);
        }

        // --- BACKEND COMMUNICATION ---
        async function sendCommand(text, skipTTS = false) {
            // Pause Mic while Computer speaks to prevent it hearing itself
            if (!skipTTS) {
                isSystemSpeaking = true;
                if(recognition) recognition.stop();
            }

            try {
                const res = await fetch(API_URL + '/command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, user_id: userId })
                });
                const data = await res.json();

                // Check for Rank Up (Game Feature)
                if (data.updates && data.updates.rank_up) {
                    playRankUpSound();
                    triggerRankAnimation(data.updates.rank_up);
                }

                if (!skipTTS) {
                    log("Computer: " + data.response, "chat");
                    speak(data.response);
                    updateStatusUI(data.updates);
                } else {
                    log(`Sync Complete: ${text}`, "system");
                    // Ensure backend state is consistent, but we trust our optimistic update.
                    // If backend returned different updates, we *could* apply them here.
                    updateStatusUI(data.updates);
                }
            } catch (err) {
                log("Backend Error: " + err, "error");
                if (!skipTTS) speak("Communication Link Severed.");
            }
        }

        function playRankUpSound() {
            // The TNG "Boatswain Whistle"
            new Audio('https://www.trekcore.com/audio/communications/boatswainwhistle.mp3').play().catch(e => console.log("Audio play error", e));
        }

        function triggerRankAnimation(newRank) {
            // Flash the screen Gold/Yellow
            document.body.style.animation = "flash-gold 1s";

            // Show overlay message
            const overlay = document.createElement('div');
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.display = 'flex';
            overlay.style.flexDirection = 'column';
            overlay.style.alignItems = 'center';
            overlay.style.justifyContent = 'center';
            overlay.style.zIndex = '1000';
            overlay.style.pointerEvents = 'none'; // Click through
            overlay.innerHTML = `<span style="color: #FFD700; font-size: 3em; font-weight: bold; text-shadow: 0 0 20px gold; text-align: center;">
                ⚠ PROMOTION AUTHORIZED ⚠<br><span style="font-size: 0.8em; color: white;">RANK: ${newRank.toUpperCase()}</span>
            </span>`;

            document.body.appendChild(overlay);

            setTimeout(() => {
                document.body.style.animation = "";
                overlay.remove();
            }, 3000);
        }

        // --- TTS (Optimized) ---
        function speak(text) {
            window.speechSynthesis.cancel(); // Clear queue

            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.1;

            utterance.onend = () => {
                isSystemSpeaking = false;
                // RE-START MIC after computer finishes speaking
                startContinuousMic();
                // Restore silent loop for button
                silentAudio.play().catch(e => {});
            };

            window.speechSynthesis.speak(utterance);
        }

        // --- STATUS POLLING (Unchanged) ---
        async function pollStatus() {
            // Fail-safe: Ensure silent audio is playing to keep button alive
            if (silentAudio.paused && !isSystemSpeaking) {
                 silentAudio.play().catch(e => {});
            }

            if (window.location.protocol === 'file:') return;
            try {
                const res = await fetch(API_URL + '/status');
                if (!res.ok) throw new Error(`HTTP error! status: ${res.status}`);
                const data = await res.json();
                renderSystems(data.systems);
            } catch (e) { console.log("Poll error", e); }
            setTimeout(pollStatus, 5000);
        }

        function updateStatusUI(updates) {
            renderSystems(updates);
        }

        function renderSystems(systems) {
            const panel = document.getElementById('status-panel');
            // Only clear if empty to avoid flickering, or use diffing.
            // For simplicity, we'll just update values if elements exist.

            if (panel.children.length === 0) {
                // Initial render
                for (const [name, level] of Object.entries(systems)) {
                    const div = document.createElement('div');
                    div.className = 'system-display';
                    div.id = `sys-${name}`;
                    div.innerHTML = `
                        <div class="bar-container">
                            <div class="bar-fill" style="height: ${level}%"></div>
                        </div>
                        <div class="system-name">${name}</div>
                        <div class="system-value">${level}%</div>
                    `;
                    panel.appendChild(div);
                }
            } else {
                // Update
                for (const [name, level] of Object.entries(systems)) {
                    const el = document.getElementById(`sys-${name}`);
                    if (el) {
                        el.querySelector('.bar-fill').style.height = `${level}%`;
                        el.querySelector('.system-value').textContent = `${level}%`;
                    }
                }
            }
        }

        // Initial load
        pollStatus();

    </script>
</body>
</html>
